// nim.txt
//
// This is the standard nim game. There are three piles of chips containing
// x1, x2, and x3 chips respectively. Two players take turns moving.
// Each move consists of selecting one of the piles and removing chips from it.
// You may not remove chips from more than one pile in one turn, but from the
// pile you selected you may remove as many chips as desired, from one chip to
// the whole pile. The winner is the player who removes the last chip.
//
// For more info on the game, please check the online book Combinatorial Game
// Theory by Thomas S. Ferguson.
//
// The property that we prove for nim games in this model is that, starting from
// configurations (i.e. triple (x1,x2,x3)) whose *nim-sum* is 0, Player 2
// has a winning strategy.
//
// In our encoding as parameterised reachability game:
// Numbers are encoded in binary - most significant digit first


// Notice that for nim-sum to be 0, then every binary position the three
// number must sum up to 0.
I0 {
    init: si;

    si -> s0 bot;
    s0 -> s0 _000_;
    s0 -> s0 _101_;
    s0 -> s0 _011_;
    s0 -> s0 _110_;

    accepting: s0;
}

F {
    init: s0;

    s0 -> s1 bott;
    s1 -> s1 _000_;
    s1 -> s1 _001_;
    s1 -> s1 _010_;
    s1 -> s1 _011_;
    s1 -> s1 _100_;
    s1 -> s1 _101_;
    s1 -> s1 _110_;
    s1 -> s1 _111_;

    accepting: s1;
}

P1 {
    init: si;

    // Empty
    si -> s0;
    s0 -> s1 bot/bott;
    s1 -> s1 _000_/_000_;

    // Nonempty: first pile
    si -> p0;
    p0 -> p1 bot/bot;
    p1 -> p1 _000_/_000_;
    p1 -> p1 _001_/_001_;
    p1 -> p1 _010_/_010_;
    p1 -> p1 _011_/_011_;
    p1 -> p1 _100_/_100_;
    p1 -> p1 _101_/_101_;
    p1 -> p1 _110_/_110_;
    p1 -> p1 _111_/_111_;

        // the first digit where the number differs (and has to decrease)
    p1 -> p2 _100_/_000_;
    p1 -> p2 _101_/_001_;
    p1 -> p2 _110_/_010_;
    p1 -> p2 _111_/_011_;

        // after this, it doesn't matter
    p2 -> p2 _000_/_000_;
    p2 -> p2 _001_/_001_;
    p2 -> p2 _010_/_010_;
    p2 -> p2 _011_/_011_;
    p2 -> p2 _100_/_100_;
    p2 -> p2 _101_/_101_;
    p2 -> p2 _110_/_110_;
    p2 -> p2 _111_/_111_;

    p2 -> p2 _000_/_100_;
    p2 -> p2 _001_/_101_;
    p2 -> p2 _010_/_110_;
    p2 -> p2 _011_/_111_;
    p2 -> p2 _100_/_000_;
    p2 -> p2 _101_/_001_;
    p2 -> p2 _110_/_010_;
    p2 -> p2 _111_/_011_;

    // Nonempty: second pile
    si -> q0;
    q0 -> q1 bot/bot;
    q1 -> q1 _000_/_000_;
    q1 -> q1 _001_/_001_;
    q1 -> q1 _010_/_010_;
    q1 -> q1 _011_/_011_;
    q1 -> q1 _100_/_100_;
    q1 -> q1 _101_/_101_;
    q1 -> q1 _110_/_110_;
    q1 -> q1 _111_/_111_;

        // the first digit where the number differs (and has to decrease)
    q1 -> q2 _010_/_000_;
    q1 -> q2 _011_/_001_;
    q1 -> q2 _110_/_100_;
    q1 -> q2 _111_/_101_;

        // after this, it doesn't matter
    q2 -> q2 _000_/_000_;
    q2 -> q2 _001_/_001_;
    q2 -> q2 _010_/_010_;
    q2 -> q2 _011_/_011_;
    q2 -> q2 _100_/_100_;
    q2 -> q2 _101_/_101_;
    q2 -> q2 _110_/_110_;
    q2 -> q2 _111_/_111_;

    q2 -> q2 _000_/_010_;
    q2 -> q2 _001_/_011_;
    q2 -> q2 _100_/_110_;
    q2 -> q2 _101_/_111_;
    q2 -> q2 _010_/_000_;
    q2 -> q2 _011_/_001_;
    q2 -> q2 _110_/_100_;
    q2 -> q2 _111_/_101_;

    // Nonempty: third pile
    si -> r0;
    r0 -> r1 bot/bot;
    r1 -> r1 _000_/_000_;
    r1 -> r1 _001_/_001_;
    r1 -> r1 _010_/_010_;
    r1 -> r1 _011_/_011_;
    r1 -> r1 _100_/_100_;
    r1 -> r1 _101_/_101_;
    r1 -> r1 _110_/_110_;
    r1 -> r1 _111_/_111_;

        // the first digit where the number differs (and has to decrease)
    r1 -> r2 _001_/_000_;
    r1 -> r2 _011_/_010_;
    r1 -> r2 _101_/_100_;
    r1 -> r2 _111_/_110_;

        // after this, it doesn't matter
    r2 -> r2 _000_/_000_;
    r2 -> r2 _001_/_001_;
    r2 -> r2 _010_/_010_;
    r2 -> r2 _011_/_011_;
    r2 -> r2 _100_/_100_;
    r2 -> r2 _101_/_101_;
    r2 -> r2 _110_/_110_;
    r2 -> r2 _111_/_111_;

    r2 -> r2 _000_/_001_;
    r2 -> r2 _010_/_011_;
    r2 -> r2 _100_/_101_;
    r2 -> r2 _110_/_111_;
    r2 -> r2 _001_/_000_;
    r2 -> r2 _011_/_010_;
    r2 -> r2 _101_/_100_;
    r2 -> r2 _111_/_110_;

    accepting: s1, p2, q2, r2;
}

P2 {
    init: si;

    //
    si -> sii;
    sii -> siii bott/bott;
    siii -> siii _000_/_000_;

    // Empty
    si -> s0;
    s0 -> s1 bot/boto; // declare Player 1 wins if empty
    s1 -> s1 _000_/_000_;

    // Nonempty: first pile
    si -> p0;
    p0 -> p1 bot/bot;
    p1 -> p1 _000_/_000_;
    p1 -> p1 _001_/_001_;
    p1 -> p1 _010_/_010_;
    p1 -> p1 _011_/_011_;
    p1 -> p1 _100_/_100_;
    p1 -> p1 _101_/_101_;
    p1 -> p1 _110_/_110_;
    p1 -> p1 _111_/_111_;

        // the first digit where the number differs (and has to decrease)
    p1 -> p2 _100_/_000_;
    p1 -> p2 _101_/_001_;
    p1 -> p2 _110_/_010_;
    p1 -> p2 _111_/_011_;

        // after this, it doesn't matter
    p2 -> p2 _000_/_000_;
    p2 -> p2 _001_/_001_;
    p2 -> p2 _010_/_010_;
    p2 -> p2 _011_/_011_;
    p2 -> p2 _100_/_100_;
    p2 -> p2 _101_/_101_;
    p2 -> p2 _110_/_110_;
    p2 -> p2 _111_/_111_;

    p2 -> p2 _000_/_100_;
    p2 -> p2 _001_/_101_;
    p2 -> p2 _010_/_110_;
    p2 -> p2 _011_/_111_;
    p2 -> p2 _100_/_000_;
    p2 -> p2 _101_/_001_;
    p2 -> p2 _110_/_010_;
    p2 -> p2 _111_/_011_;

    // Nonempty: second pile
    si -> q0;
    q0 -> q1 bot/bot;
    q1 -> q1 _000_/_000_;
    q1 -> q1 _001_/_001_;
    q1 -> q1 _010_/_010_;
    q1 -> q1 _011_/_011_;
    q1 -> q1 _100_/_100_;
    q1 -> q1 _101_/_101_;
    q1 -> q1 _110_/_110_;
    q1 -> q1 _111_/_111_;

        // the first digit where the number differs (and has to decrease)
    q1 -> q2 _010_/_000_;
    q1 -> q2 _011_/_001_;
    q1 -> q2 _110_/_100_;
    q1 -> q2 _111_/_101_;

        // after this, it doesn't matter
    q2 -> q2 _000_/_000_;
    q2 -> q2 _001_/_001_;
    q2 -> q2 _010_/_010_;
    q2 -> q2 _011_/_011_;
    q2 -> q2 _100_/_100_;
    q2 -> q2 _101_/_101_;
    q2 -> q2 _110_/_110_;
    q2 -> q2 _111_/_111_;

    q2 -> q2 _000_/_010_;
    q2 -> q2 _001_/_011_;
    q2 -> q2 _100_/_110_;
    q2 -> q2 _101_/_111_;
    q2 -> q2 _010_/_000_;
    q2 -> q2 _011_/_001_;
    q2 -> q2 _110_/_100_;
    q2 -> q2 _111_/_101_;

    // Nonempty: third pile
    si -> r0;
    r0 -> r1 bot/bot;
    r1 -> r1 _000_/_000_;
    r1 -> r1 _001_/_001_;
    r1 -> r1 _010_/_010_;
    r1 -> r1 _011_/_011_;
    r1 -> r1 _100_/_100_;
    r1 -> r1 _101_/_101_;
    r1 -> r1 _110_/_110_;
    r1 -> r1 _111_/_111_;

        // the first digit where the number differs (and has to decrease)
    r1 -> r2 _001_/_000_;
    r1 -> r2 _011_/_010_;
    r1 -> r2 _101_/_100_;
    r1 -> r2 _111_/_110_;

        // after this, it doesn't matter
    r2 -> r2 _000_/_000_;
    r2 -> r2 _001_/_001_;
    r2 -> r2 _010_/_010_;
    r2 -> r2 _011_/_011_;
    r2 -> r2 _100_/_100_;
    r2 -> r2 _101_/_101_;
    r2 -> r2 _110_/_110_;
    r2 -> r2 _111_/_111_;

    r2 -> r2 _000_/_001_;
    r2 -> r2 _010_/_011_;
    r2 -> r2 _100_/_101_;
    r2 -> r2 _110_/_111_;
    r2 -> r2 _001_/_000_;
    r2 -> r2 _011_/_010_;
    r2 -> r2 _101_/_100_;
    r2 -> r2 _111_/_110_;

    accepting: s1, p2, q2, r2, siii;
}

transducerStateGuessing: 1 .. 10;
automatonStateGuessing: 0 .. 4;

useRankingFunctions;
