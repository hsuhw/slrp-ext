// lr-philo.txt
//
// Left-Right (deterministic) Dining Philosopher Protocol
//
// Leftmost philosopher (in a linearisation of the circular order) picks
// right first, and then left. The other philosophers pick up the left fork
// first.
//
// T - Thinking
// L - Having only left fork
// R - Having only right fork
// E - Both forks held
//

// At least three philosophers
I0 {
    init: s0;

    s0 -> s1 T;
    s1 -> s2 T;
    s2 -> s3 T;
    s3 -> s3 T;

    accepting: s3;
}

closedUnderTransitions;

// One philosopher eats
F {
    init: s0;

    s0 -> s0 T;
    s0 -> s0 L;
    s0 -> s0 R;

    s0 -> s1 E;

    s1 -> s1 T;
    s1 -> s1 L;
    s1 -> s1 R;

    accepting: s1;
}

P1 {
    init: sinit;

    sinit -> s0;
    sinit -> ssE T/nil;
    sinit -> ssE L/nil;
    sinit -> ssE R/nil;
    sinit -> ssE nil/nil;

    s0 -> ss T_/nil;
    s0 -> ss L/nil;
    s0 -> ss L_/nil;
    s0 -> ss R_/nil;
    s0 -> ss E/nil;
    s0 -> ss nil/nil;

    // Choose first philo

        // t1 - leftmost philo thinks is picked
    s0 -> t1 T/T_;

            // The second guy should not have a fork
    t1 -> t12 T/T;
    t1 -> ss T_/nil;
    t1 -> ss L_/nil;
    t1 -> ss R/nil;
    t1 -> ss R_/nil;
    t1 -> ss E/nil;
    t1 -> ss nil/nil;

    t12 -> t12 T/T;
    t12 -> t12 L/L;
    t12 -> ss T_/nil;
    t12 -> ss L_/nil;
    t12 -> ss R/nil;
    t12 -> ss R_/nil;
    t12 -> ss E/nil;
    t12 -> ss nil/nil;

        // r1 - leftmost philo (already with a right fork) is picked
    s0 -> r1 R/R_;

            // The second guy should not have a fork
    r1 -> r12 T/T;
    r1 -> ss T_/nil;
    r1 -> ss L/nil;
    r1 -> ss L_/nil;
    r1 -> ss R/nil;
    r1 -> ss R_/nil;
    r1 -> ss E/nil;
    r1 -> ss nil/nil;


    r12 -> r12 T/T;
    r12 -> r12 L/L;
    r12 -> ss T_/nil;
    r12 -> ss L_/nil;
    r12 -> ss R/nil;
    r12 -> ss R_/nil;
    r12 -> ss E/nil;
    r12 -> ss nil/nil;

    // Choose something other than the first philo

        // t2 - leftmost philo thinks but not picked
    s0 -> t2 T/T;

    t2 -> t2 T/T;
    t2 -> t2 L/L;
    t2 -> ss T_/nil;
    t2 -> ss L_/nil;
    t2 -> ss R/nil;
    t2 -> ss R_/nil;
    t2 -> ss E/nil;
    t2 -> ss nil/nil;

        // the guy picked is thinking
    t2 -> tt2 T/T_;
        // the guy picked is holding a left fork
    t2 -> tl2 L/L_;
    t2 -> ss T_/nil;
    t2 -> ss L_/nil;
    t2 -> ss R/nil;
    t2 -> ss R_/nil;
    t2 -> ss E/nil;
    t2 -> ss nil/nil;

    tt2 -> tt2 T/T;
    tt2 -> tt2 L/L;
    tt2 -> ss T_/nil;
    tt2 -> ss L_/nil;
    tt2 -> ss R/nil;
    tt2 -> ss R_/nil;
    tt2 -> ss E/nil;
    tt2 -> ss nil/nil;

        // next to the guy P picked must not hold a left fork (or if P is the
        // rightmost guy, then don't care, i.e., add tl2 as a final state)
    tl2 -> tl3 T/T;
    tl2 -> ss T_/nil;
    tl2 -> ss L_/nil;
    tl2 -> ss R/nil;
    tl2 -> ss R_/nil;
    tl2 -> ss E/nil;
    tl2 -> ss nil/nil;

    tl3 -> tl3 T/T;
    tl3 -> tl3 L/L;
    tl3 -> ss T_/nil;
    tl3 -> ss L_/nil;
    tl3 -> ss R/nil;
    tl3 -> ss R_/nil;
    tl3 -> ss E/nil;
    tl3 -> ss nil/nil;

        // r2 - leftmost philo with a right fork but not picked
    s0 -> ri2 R/R;

    ri2 -> r2 T/T;
    ri2 -> ss T_/nil;
    ri2 -> ss L/nil;
    ri2 -> ss L_/nil;
    ri2 -> ss R/nil;
    ri2 -> ss R_/nil;
    ri2 -> ss E/nil;
    ri2 -> ss nil/nil;

    r2 -> r2 T/T;
    r2 -> r2 L/L;
    r2 -> ss T_/nil;
    r2 -> ss L_/nil;
    r2 -> ss R/nil;
    r2 -> ss R_/nil;
    r2 -> ss E/nil;
    r2 -> ss nil/nil;

        // the guy picked is thinking
    r2 -> rt2 T/T_;
        // the guy picked is holding a left fork
    r2 -> rl2 L/L_;

    rt2 -> rt2 T/T;
    rt2 -> rt2 L/L;
    rt2 -> ss T_/nil;
    rt2 -> ss L_/nil;
    rt2 -> ss R/nil;
    rt2 -> ss R_/nil;
    rt2 -> ss E/nil;
    rt2 -> ss nil/nil;

        // here rl2 is not a final state unlike in the case of tl2
    rl2 -> rl3 T/T;
    rl2 -> ss T_/nil;
    rl2 -> ss L_/nil;
    rl2 -> ss R/nil;
    rl2 -> ss R_/nil;
    rl2 -> ss E/nil;
    rl2 -> ss nil/nil;

    rl3 -> rl3 T/T;
    rl3 -> rl3 L/L;
    rl3 -> ss T_/nil;
    rl3 -> ss L_/nil;
    rl3 -> ss R/nil;
    rl3 -> ss R_/nil;
    rl3 -> ss E/nil;
    rl3 -> ss nil/nil;

    ss ->  ss T/nil;
    ss ->  ss T_/nil;
    ss ->  ss R/nil;
    ss ->  ss R_/nil;
    ss ->  ss L/nil;
    ss ->  ss L_/nil;
    ss ->  ss E/nil;
    ss ->  ss nil/nil;

    ssE ->  ssE E/nil;

    accepting: t12, r12, tt2, tl2, tl3, rt2, rl3, ss, ssE;
}

P2 {
    init: s0;

    // Not the first process
    s0 -> p0 T/T;
    s0 -> p0 R/R;

    p0 -> p0 T/T;
    p0 -> p0 L/L;

    p0 -> p1 T_/L;
    p0 -> p1 L_/E;

    p1 -> p1 T/T;
    p1 -> p1 L/L;

    // The first process
    s0 -> p1 T_/R;
    s0 -> p1 R_/E;

    accepting: p1;
}

transducerStateGuessing: 1 .. 10;
automatonStateGuessing: 1 .. 5;
