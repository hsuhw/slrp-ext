I0 {
    init: s0;

    sn -> sn _0_;
    s0 -> s1 _1_;
    s1 -> s2 _1_;
    s2 -> s3 _1_;
    s3 -> s0 _1_;
    s0 -> sn _0_;

    accepting: s0, sn;
}

F {
    init: s0;
    s0 -> s0 _0_;
    accepting: s0;
}

P1 {
    init: s0;
    s0 -> sk _1_/_1_;

    s0 -> sn _1_/_2_;
    s0 -> s1 _1_/_2_;
    s0 -> s2 _1_/_2_;

    sk -> sk _1_/_1_;
    sn -> sn _0_/_0_;

    sk -> sn _1_/_0_;
    sk -> s2 _1_/_0_;
    sk -> s1 _1_/_0_;

    s1 -> s2 _1_/_0_;
    s2 -> sn _1_/_0_;
    accepting: sn;
}

P2 {
    init: sk;
    sk -> sk _1_/_1_;
    sn -> sn _0_/_0_;

    sk -> sn _1_/_0_;
    sk -> s2 _1_/_0_;
    sk -> s1 _1_/_0_;

    s1 -> s2 _1_/_0_;
    s2 -> sn _1_/_0_;
    accepting: sn;
}

transducerStateGuessing: 1 .. 7;
automatonStateGuessing: 1 .. 8;

// useRankingFunctions;         // not used for benchmarking
